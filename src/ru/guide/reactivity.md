# Подробнее о реактивности

Пришло время нырнуть поглубже в тему! Одна из наиболее примечательных возможностей Vue — ненавязчивая реактивность. Модели представляют собой проксированные JavaScript-объекты. По мере их изменения обновляется и представление данных. Это делает управление состоянием приложения простым и очевидным. Тем не менее, у механизма реактивности есть ряд особенностей, знакомство с которыми позволит избежать распространённых ошибок. В этом разделе рассмотрим подробнее низкоуровневую реализацию системы реактивности Vue.

## Что такое реактивность?

В последнее время этот термин часто используется в программировании, но что он значит? Реактивность — концепция, которая позволяет нам приспособиться к изменениям декларативным способом. Отличный канонический пример, который обычно демонстрируется — электронная таблица в Excel.

<video width="550" height="400" controls>
  <source src="/images/reactivity-spreadsheet.mp4" type="video/mp4">
  Ваш браузер не поддерживает тег video.
</video>

Если ввести цифру 2 в первую ячейку, 3 во вторую и попробовать получить сумму с помощью встроенной в Excel функции SUM, таблица её посчитает. Ничего неожиданного. Но если повторно изменить число в первой ячейке, сумма тоже автоматически обновится.

Обычно JavaScript так не работает. Что-то подобное на JavaScript выглядело бы так:

```js
var val1 = 2
var val2 = 3
var sum = val1 + val2

// sum
// 5

val1 = 3

// sum
// 5
```

Если изменить первое значение, сумма не обновится с его учётом.

Итак, как это сделать в JavaScript?

- Определить, когда одно из значений изменяется
- Отслеживать функцию, которая их изменяет
- Вызвать функцию, которая обновит конечный результат

## Как Vue отслеживает изменения

Когда простой JavaScript-объект передаётся в приложение или экземпляр Vue в качестве опции `data`, Vue обходит все его свойства и преобразует их в [Proxy](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy), используя обработчик с геттерами и сеттерами. Эта возможность присутствует только в ES6, но Vue 3 также поддерживает старый подход с `Object.defineProperty` для совместимости с браузерами IE. Обе версии предоставляют одинаковое API, но версия с Proxy более легковесная и производительная.

<div class="reactivecontent">
  <common-codepen-snippet title="Визуальное объяснение Proxy и реактивности во Vue" slug="zYYzjBg" tab="result" theme="light" :height="500" :team="false" user="sdras" name="Sarah Drasner" :editable="false" :preview="false" />
</div>

Это было поверхностное объяснение и оно требует некоторых знаний о [Proxy](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy) для полного понимания. Давайте немного углубимся. Есть достаточно много литературы про Proxy, но что вам действительно важно знать, что **Proxy — объект, который содержит в себе другой объект или функцию и позволяет "перехватить" их.**

Вот как это можно использовать: `new Proxy(target, handler)`

```js
const dinner = {
  meal: 'tacos'
}

const handler = {
  get(target, prop) {
    return target[prop]
  }
}

const proxy = new Proxy(dinner, handler)
console.log(proxy.meal)

// tacos
```

Пока что объект просто оборачивается и возвращается. Круто, но ещё не так полезно. Но взгляните сюда, этот объект можно перехватить во время оборачивания его в Proxy. Этот перехват называется ловушкой. 

```js
const dinner = {
  meal: 'tacos'
}

const handler = {
  get(target, prop) {
    console.log('перехвачен!')
    return target[prop]
  }
}

const proxy = new Proxy(dinner, handler)
console.log(proxy.meal)

// перехвачен!
// tacos
```

Помимо вывода в консоль можно сделать всё что угодно. Кроме этого, при желании можно даже _не возвращать_ значение. Вот поэтому Proxy настолько эффективен для создания API.

У Proxy есть ещё одна особенность. Вместо того, чтобы просто вернуть значение в виде: `target[prop]`, можно пойти дальше и воспользоваться `Reflect`, чтобы корректно привязать `this`. Получится примерно следующее:

```js{7}
const dinner = {
  meal: 'tacos'
}

const handler = {
  get(target, prop, receiver) {
    return Reflect.get(...arguments)
  }
}

const proxy = new Proxy(dinner, handler)
console.log(proxy.meal)

// tacos
```

Как упоминалось ранее, чтобы API обновил результат при каком-либо изменении, нужно установить новые значения. Давайте сделаем это в функции-обработчике `track`, куда передаётся `target` и `key`.

```js{7}
const dinner = {
  meal: 'tacos'
}

const handler = {
  get(target, prop, receiver) {
    track(target, prop)
    return Reflect.get(...arguments)
  }
}

const proxy = new Proxy(dinner, handler)
console.log(proxy.meal)

// tacos
```

Наконец, установим новые значения, когда что-то поменяется. Для этого обновим эти данные с помощью нашего нового прокси, вызвав эти изменения:

```js
const dinner = {
  meal: 'tacos'
}

const handler = {
  get(target, prop, receiver) {
    track(target, prop)
    return Reflect.get(...arguments)
  },
  set(target, key, value, receiver) {
    trigger(target, key)
    return Reflect.set(...arguments)
  }
}

const proxy = new Proxy(dinner, handler)
console.log(proxy.meal)

// tacos
```

Помните, этот список уже рассматривался несколькими абзацами ранее? Теперь у нас есть ответы на вопросы как Vue обрабатывает изменения:

- <strike>Определить, когда одно из значений изменяется</strike>: больше не нужно этого делать, т.к. Proxy позволяют перехватить изменение
- **Найти функцию, которая их изменяет**: Этот пункт выполняется в геттере `effect`
- **Вызвать функцию, чтобы она обновила конечный результат**: Выполняется в сеттере внутри прокси `trigger`

Проксированный объект невидим для пользователя, но под капотом он позволяет Vue следить за изменениями и уведомлять о них при обращении или редактировании свойств объекта. Начиная с Vue 3, реализация реактивности теперь доступна как [отдельный модуль](https://github.com/vuejs/vue-next/tree/master/packages/reactivity). Оговоримся, что преобразованные объекты логируются в консоли по-разному для разных браузеров. Для более удобной работы с такими объектами можно использовать [vue-devtools](https://github.com/vuejs/vue-devtools).

### Проксированные объекты

Под капотом Vue отслеживает все реактивные объекты, благодаря этому для каждого объекта возвращается свой Proxy.

Когда требуется доступ к вложенному объекту внутри реактивной Proxy, этот объект _тоже конвертируется_ в Proxy и потом возвращается.

```js
const handler = {
  get(target, prop, receiver) {
    track(target, prop)
    const value = Reflect.get(...arguments)
    if (isObject(value)) {
      return reactive(value)
    } else {
      return value
    }
  }
  // ...
}
```

### Proxy vs оригинальная сущность

При использовании Proxy следует помнить о том, что проксируемый объект не равен оригинальному объекту при строгом сравнении (`===`). Например:

```js
const obj = {}
const wrapped = new Proxy(obj, handlers)

console.log(obj === wrapped) // false
```

Оригинальный и обёрнутый в Proxy объект в большинстве случаев ведут себя одинаково, но могут выдать неправильный результат в операциях со строгим сравнением, таких как `.filter()` или `.map()`. Эта особенность вряд ли возникнет при использовании Options API, так как свойства реактивного состояния вызываются из `this` и гарантированно используют Proxy.

Тем не менее, при использовании composition API для явного создания реактивных объектов, хорошей практикой считается никогда не сохранять ссылку на оригинальный объект и работать только с реактивной версией.

```js
const obj = reactive({
  count: 0
}) // не ссылается на оригинал
```

## Наблюдатели

У каждого экземпляра компонента есть соответствующий наблюдатель, который вносит в зависимости любые свойства, используемые в момент отрисовки. Позже, при срабатывании сеттера зависимости, он уведомит наблюдателя, что приведёт к перерисовке компонента.

<div class="reactivecontent">
  <common-codepen-snippet title="Второе объяснение рактивности с Proxy во Vue 3" slug="GRJZddR" tab="result" theme="light" :height="500" :team="false" user="sdras" name="Sarah Drasner" :editable="false" :preview="false" />
</div>

Когда объект данных передаётся в экземпляр компонента, Vue превращает его в Proxy. С помощью Proxy Vue сможет следить за зависимостями и получать уведомления об их изменениях. Каждое свойство рассматривается как зависимость.

После первой отрисовки у компонента будет список отслеживаемых зависимостей, полученный из свойств, вызванных в момент отрисовки. И наоборот, компонент подписывается на каждое из этих свойств. Когда прокси перехватывает операцию обновления, все подписанные на свойство компоненты будут уведомлены и перерисованы.

<!-- [//]: # 'TODO: Insert diagram' -->

> При использовании Vue 2.x или более ранних версий, есть некоторые оговорки, о которых подробнее можно узнать [здесь](change-detection.md).
